{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"logproc","text":"<p>Run a process and live log stdin and stdout.</p>"},{"location":"#description","title":"Description","text":"<p>This experimental module allows you to run an external program in the background and to live capture and handle its standard output and standard error.</p> <p>Each captured line of output is immediately forwarded to the logging system (or whatever handler you provide) so that you can immediately see the output if you are logging to console. Both an asynchronous and a synchronous API is provided.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>In the simplest case, just run <code>execute([\"ls\", \"-l\"])</code>, which will run <code>ls -l</code> and log its output with Python\u2019s default logging system, using the logger id <code>ls</code> and the level INFO for stdout, WARNING for stderr.</p> <p>If you already run an asynchronous event loop, you can use the asynchronous API by running <code>await aexecute([\"ls\", \"-l\"])</code> instead.</p> <p>For more details, see the API reference</p>"},{"location":"#launching-processes-in-parallel","title":"Launching processes in parallel","text":"<p>Sometimes it is useful to launch multiple processes in parallel and capture their output as it appears, while still limiting the number of concurrent processes (e.g., to the number of available CPU cores). This is possible using <code>map_unordered</code>. E.g.,</p> <pre><code>async def render_graphs(folder: Path):\n    commands = ([\"dot\", \"-Tsvg\", \"-o\", fspath(file.with_suffix(\".svg\")), fspath(file)] \n                for file in folder.glob(\"*.dot\"))\n    async for result in map_unordered(aexecute, commands):\n        # Process the result\n        pass\n</code></pre> <p>calls <code>dot</code> for each <code>*.dot</code> file in the given folder, limiting the number of concurrent jobs to the number of available CPU cores.</p>"},{"location":"api/","title":"API Documentation","text":"<p>Run a process and log stdin and stdout.</p> <p>This experimental module offers a function <code>execute()</code> that runs a commandline in a subprocess and separately live captures the called process\u2019s standard output and standard error. By default, the output is logged at different levels, but it is possible to provide a callback for different handling.</p> <p>Functions:</p> <ul> <li> <code>aexecute</code>             \u2013              <p>Asynchronously run the given command and log its output as it appears.</p> </li> <li> <code>execute</code>             \u2013              <p>Run the given command and log its output as it appears, blocking while the program runs.</p> </li> <li> <code>limit_concurrency</code>             \u2013              <p>Run at most <code>limit</code> of the given awaitables concurrently, yielding completed tasks as they finish.</p> </li> <li> <code>map_unordered</code>             \u2013              <p>Executes the given async function <code>func</code> on each item from <code>iterable</code>, yielding results as they complete, while limiting the number of concurrent tasks to <code>limit</code>.</p> </li> <li> <code>proc_logger</code>             \u2013              <p>Creates a callback for execute() that logs to a logger.</p> </li> </ul>"},{"location":"api/#logproc.aexecute","title":"aexecute  <code>async</code>","text":"<pre><code>aexecute(\n    cmd,\n    stdout=None,\n    stdout_level=INFO,\n    stderr=None,\n    stderr_level=WARNING,\n    cwd=None,\n    prefix=\"\",\n    **kwargs,\n)\n</code></pre> <p>Asynchronously run the given command and log its output as it appears.</p> Description <p><code>aexecute</code> runs the given command and waits for it to finish. While it is running, its stdout and stderr streams are monitored. Each new line appearing on these streams are immediately handled.</p> <p>The default handlers will log the message from the subprocess to a logger that logs using the first member of the cmd sequence as a logger name and logging.INFO for stdout and logging.WARNING for stderr output.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>Sequence[str]</code>)           \u2013            <p>A list of arguments, as in subprocess.run etc.</p> </li> <li> <code>stdout</code>               (<code>OutputHandler | None</code>, default:                   <code>None</code> )           \u2013            <p>Handlers for the standard output stream. Each of these can be:</p> <ul> <li>None (the default) to use the default settings</li> <li>a logger name</li> <li>a <code>logging.Logger</code></li> <li>a callback that receives a line as <code>str</code> or <code>bytes</code> as argument and handles that</li> </ul> </li> <li> <code>stderr</code>               (<code>OutputHandler | None</code>, default:                   <code>None</code> )           \u2013            <p>Like stdout, but for standard error.</p> </li> <li> <code>stdout_level</code>               (<code>int</code>, default:                   <code>INFO</code> )           \u2013            </li> <li> <code>stderr_level</code>               (<code>int</code>, default:                   <code>WARNING</code> )           \u2013            <p>Logging levels for the specific output.</p> </li> <li> <code>prefix</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A string that is prepended to each line before logging.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional keyword arguments to be passed to asyncio.create_subprocess_exec</p> </li> </ul> <p>Returns:     the command\u2019s exit code</p>"},{"location":"api/#logproc.execute","title":"execute","text":"<pre><code>execute(\n    cmd,\n    stdout=None,\n    stdout_level=INFO,\n    stderr=None,\n    stderr_level=WARNING,\n    cwd=None,\n    prefix=\"\",\n    **kwargs,\n)\n</code></pre> <p>Run the given command and log its output as it appears, blocking while the program runs.</p> Description <p><code>execute</code> runs the given command and waits for it to finish. While it is running, its stdout and stderr streams are monitored. Each new line appearing on these streams are immediately handled.</p> <p>The default handlers will log the message from the subprocess to a logger that logs using the first member of the cmd sequence as a logger name and logging.INFO for stdout and logging.WARNING for stderr output.</p> <p>Parameters:</p> <ul> <li> <code>cmd</code>               (<code>Sequence[str]</code>)           \u2013            <p>A list of arguments, as in subprocess.run etc.</p> </li> <li> <code>stdout</code>               (<code>OutputHandler | None</code>, default:                   <code>None</code> )           \u2013            <p>Handlers for the standard output stream. Each of these can be:</p> <ul> <li>None (the default) to use the default settings</li> <li>a logger name</li> <li>a <code>logging.Logger</code></li> <li>a callback that receives a line as <code>str</code> or <code>bytes</code> as argument and handles that</li> </ul> </li> <li> <code>stderr</code>               (<code>OutputHandler | None</code>, default:                   <code>None</code> )           \u2013            <p>Like stdout, but for standard error.</p> </li> <li> <code>stdout_level</code>               (<code>int</code>, default:                   <code>INFO</code> )           \u2013            </li> <li> <code>stderr_level</code>               (<code>int</code>, default:                   <code>WARNING</code> )           \u2013            <p>Logging levels for the specific output.</p> </li> <li> <code>prefix</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A string that is prepended to each line before logging.</p> </li> <li> <code>kwargs</code>           \u2013            <p>Additional keyword arguments to be passed to asyncio.create_subprocess_exec</p> </li> </ul> <p>Returns:     the command\u2019s exit code</p> See also <p>aexecute()</p>"},{"location":"api/#logproc.limit_concurrency","title":"limit_concurrency  <code>async</code>","text":"<pre><code>limit_concurrency(tasks, limit=None)\n</code></pre> <p>Run at most <code>limit</code> of the given awaitables concurrently, yielding completed tasks as they finish.</p>"},{"location":"api/#logproc.map_unordered","title":"map_unordered  <code>async</code>","text":"<pre><code>map_unordered(func, iterable, *, limit=None)\n</code></pre> <p>Executes the given async function <code>func</code> on each item from <code>iterable</code>, yielding results as they complete, while limiting the number of concurrent tasks to <code>limit</code>. This function will not consume more items from iterable than it can start while maintaining the concurrency limit.</p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable[[T], Awaitable[R]]</code>)           \u2013            <p>a coroutine function to apply to each item of the given iterable</p> </li> <li> <code>iterable</code>               (<code>Iterable[T] | AsyncIterable[T]</code>)           \u2013            <p>an iterable or async iterable of items to process</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum number of concurrent tasks. If None, defaults to the number of CPU cores available to the process.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>AsyncGenerator[R, None]</code>           \u2013            <p>The results of the function calls, in the order they complete.</p> </li> </ul> See also <p>https://death.andgravity.com/limit-concurrency</p>"},{"location":"api/#logproc.proc_logger","title":"proc_logger","text":"<pre><code>proc_logger(prefix='', level=INFO, logger=None, extra=None)\n</code></pre> <p>Creates a callback for execute() that logs to a logger.</p> <p>Parameters:</p> <ul> <li> <code>prefix</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>String that will be prepended to each line</p> </li> <li> <code>logger</code>               (<code>LoggerSpec</code>, default:                   <code>None</code> )           \u2013            <p>If given, this is either a logger or the name of a logger.     If missing, we log to the root logger.</p> </li> <li> <code>level</code>               (<code>int</code>, default:                   <code>INFO</code> )           \u2013            <p>The level at which to log the messages.</p> </li> </ul>"}]}