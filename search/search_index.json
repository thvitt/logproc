{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"logproc Run a process and live log stdin and stdout. Description This experimental module allows you to run an external program in the background and to live capture and handle its standard output and standard error. Each captured line of output is immediately forwarded to the logging system (or whatever handler you provide) so that you can immediately see the output if you are logging to console. Both an asynchronous and a synchronous API is provided. Basic Usage In the simplest case, just run execute([\"ls\", \"-l\"]) , which will run ls -l and log its output with Python\u2019s default logging system, using the logger id ls and the level INFO for stdout, WARNING for stderr. If you already run an asynchronous event loop, you can use the asynchronous API by running await aexecute([\"ls\", \"-l\"]) instead. For more details, see the API reference Launching processes in parallel Sometimes it is useful to launch multiple processes in parallel and capture their output as it appears, while still limiting the number of concurrent processes (e.g., to the number of available CPU cores). This is possible using map_unordered . E.g., async def render_graphs(folder: Path): commands = ([\"dot\", \"-Tsvg\", \"-o\", fspath(file.with_suffix(\".svg\")), fspath(file)] for file in folder.glob(\"*.dot\")) async for result in map_unordered(aexecute, commands): # Process the result pass calls dot for each *.dot file in the given folder, limiting the number of concurrent jobs to the number of available CPU cores.","title":"logproc"},{"location":"#logproc","text":"Run a process and live log stdin and stdout.","title":"logproc"},{"location":"#description","text":"This experimental module allows you to run an external program in the background and to live capture and handle its standard output and standard error. Each captured line of output is immediately forwarded to the logging system (or whatever handler you provide) so that you can immediately see the output if you are logging to console. Both an asynchronous and a synchronous API is provided.","title":"Description"},{"location":"#basic-usage","text":"In the simplest case, just run execute([\"ls\", \"-l\"]) , which will run ls -l and log its output with Python\u2019s default logging system, using the logger id ls and the level INFO for stdout, WARNING for stderr. If you already run an asynchronous event loop, you can use the asynchronous API by running await aexecute([\"ls\", \"-l\"]) instead. For more details, see the API reference","title":"Basic Usage"},{"location":"#launching-processes-in-parallel","text":"Sometimes it is useful to launch multiple processes in parallel and capture their output as it appears, while still limiting the number of concurrent processes (e.g., to the number of available CPU cores). This is possible using map_unordered . E.g., async def render_graphs(folder: Path): commands = ([\"dot\", \"-Tsvg\", \"-o\", fspath(file.with_suffix(\".svg\")), fspath(file)] for file in folder.glob(\"*.dot\")) async for result in map_unordered(aexecute, commands): # Process the result pass calls dot for each *.dot file in the given folder, limiting the number of concurrent jobs to the number of available CPU cores.","title":"Launching processes in parallel"},{"location":"api/","text":"API Documentation logproc Run a process and log stdin and stdout. This experimental module offers a function execute() that runs a commandline in a subprocess and separately live captures the called process\u2019s standard output and standard error. By default, the output is logged at different levels, but it is possible to provide a callback for different handling. Functions: aexecute \u2013 Asynchronously run the given command and log its output as it appears. execute \u2013 Run the given command and log its output as it appears, blocking while the program runs. limit_concurrency \u2013 Run at most limit of the given awaitables concurrently, yielding completed tasks as they finish. map_unordered \u2013 Executes the given async function func on each item from iterable , yielding results as they complete, while limiting the number of concurrent tasks to limit . proc_logger \u2013 Creates a callback for execute() that logs to a logger. aexecute ( cmd , stdout = None , stdout_level = logging . INFO , stderr = None , stderr_level = logging . WARNING , cwd = None , prefix = '' ) async Asynchronously run the given command and log its output as it appears. Description aexecute runs the given command and waits for it to finish. While it is running, its stdout and stderr streams are monitored. Each new line appearing on these streams are immediately handled. The default handlers will log the message from the subprocess to a logger that logs using the first member of the cmd sequence as a logger name and logging.INFO for stdout and logging.WARNING for stderr output. Parameters: cmd ( Sequence [ str ] ) \u2013 A list of arguments, as in subprocess.run etc. stdout ( OutputHandler | None , default: None ) \u2013 Handlers for the standard output stream. Each of these can be: None (the default) to use the default settings a logger name a logging.Logger a callback that receives a line as str or bytes as argument and handles that stderr ( OutputHandler | None , default: None ) \u2013 Like stdout, but for standard error. stdout_level ( int , default: INFO ) \u2013 stderr_level ( int , default: WARNING ) \u2013 Logging levels for the specific output. prefix ( str , default: '' ) \u2013 A string that is prepended to each line before logging. Returns: the command\u2019s exit code execute ( cmd , stdout = None , stdout_level = logging . INFO , stderr = None , stderr_level = logging . WARNING , cwd = None , prefix = '' ) Run the given command and log its output as it appears, blocking while the program runs. Description execute runs the given command and waits for it to finish. While it is running, its stdout and stderr streams are monitored. Each new line appearing on these streams are immediately handled. The default handlers will log the message from the subprocess to a logger that logs using the first member of the cmd sequence as a logger name and logging.INFO for stdout and logging.WARNING for stderr output. Parameters: cmd ( Sequence [ str ] ) \u2013 A list of arguments, as in subprocess.run etc. stdout ( OutputHandler | None , default: None ) \u2013 Handlers for the standard output stream. Each of these can be: None (the default) to use the default settings a logger name a logging.Logger a callback that receives a line as str or bytes as argument and handles that stderr ( OutputHandler | None , default: None ) \u2013 Like stdout, but for standard error. stdout_level ( int , default: INFO ) \u2013 stderr_level ( int , default: WARNING ) \u2013 Logging levels for the specific output. prefix ( str , default: '' ) \u2013 A string that is prepended to each line before logging. Returns: the command\u2019s exit code See also aexecute() limit_concurrency ( tasks , limit = None ) async Run at most limit of the given awaitables concurrently, yielding completed tasks as they finish. map_unordered ( func , iterable , * , limit = None ) async Executes the given async function func on each item from iterable , yielding results as they complete, while limiting the number of concurrent tasks to limit . This function will not consume more items from iterable than it can start while maintaining the concurrency limit. Parameters: func ( Callable [[ T ], Awaitable [ R ]] ) \u2013 a coroutine function to apply to each item of the given iterable iterable ( Iterable [ T ] | AsyncIterable [ T ] ) \u2013 an iterable or async iterable of items to process limit ( int | None , default: None ) \u2013 Maximum number of concurrent tasks. If None, defaults to the number of CPU cores available to the process. Returns: AsyncGenerator [ R , None] \u2013 The results of the function calls, in the order they complete. See also https://death.andgravity.com/limit-concurrency proc_logger ( prefix = '' , level = logging . INFO , logger = None , extra = None ) Creates a callback for execute() that logs to a logger. Parameters: prefix ( str , default: '' ) \u2013 String that will be prepended to each line logger ( LoggerSpec , default: None ) \u2013 If given, this is either a logger or the name of a logger. If missing, we log to the root logger. level ( int , default: INFO ) \u2013 The level at which to log the messages.","title":"API Documentation"},{"location":"api/#api-documentation","text":"","title":"API Documentation"},{"location":"api/#logproc","text":"Run a process and log stdin and stdout. This experimental module offers a function execute() that runs a commandline in a subprocess and separately live captures the called process\u2019s standard output and standard error. By default, the output is logged at different levels, but it is possible to provide a callback for different handling. Functions: aexecute \u2013 Asynchronously run the given command and log its output as it appears. execute \u2013 Run the given command and log its output as it appears, blocking while the program runs. limit_concurrency \u2013 Run at most limit of the given awaitables concurrently, yielding completed tasks as they finish. map_unordered \u2013 Executes the given async function func on each item from iterable , yielding results as they complete, while limiting the number of concurrent tasks to limit . proc_logger \u2013 Creates a callback for execute() that logs to a logger.","title":"logproc"},{"location":"api/#logproc.aexecute","text":"Asynchronously run the given command and log its output as it appears. Description aexecute runs the given command and waits for it to finish. While it is running, its stdout and stderr streams are monitored. Each new line appearing on these streams are immediately handled. The default handlers will log the message from the subprocess to a logger that logs using the first member of the cmd sequence as a logger name and logging.INFO for stdout and logging.WARNING for stderr output. Parameters: cmd ( Sequence [ str ] ) \u2013 A list of arguments, as in subprocess.run etc. stdout ( OutputHandler | None , default: None ) \u2013 Handlers for the standard output stream. Each of these can be: None (the default) to use the default settings a logger name a logging.Logger a callback that receives a line as str or bytes as argument and handles that stderr ( OutputHandler | None , default: None ) \u2013 Like stdout, but for standard error. stdout_level ( int , default: INFO ) \u2013 stderr_level ( int , default: WARNING ) \u2013 Logging levels for the specific output. prefix ( str , default: '' ) \u2013 A string that is prepended to each line before logging. Returns: the command\u2019s exit code","title":"aexecute"},{"location":"api/#logproc.execute","text":"Run the given command and log its output as it appears, blocking while the program runs. Description execute runs the given command and waits for it to finish. While it is running, its stdout and stderr streams are monitored. Each new line appearing on these streams are immediately handled. The default handlers will log the message from the subprocess to a logger that logs using the first member of the cmd sequence as a logger name and logging.INFO for stdout and logging.WARNING for stderr output. Parameters: cmd ( Sequence [ str ] ) \u2013 A list of arguments, as in subprocess.run etc. stdout ( OutputHandler | None , default: None ) \u2013 Handlers for the standard output stream. Each of these can be: None (the default) to use the default settings a logger name a logging.Logger a callback that receives a line as str or bytes as argument and handles that stderr ( OutputHandler | None , default: None ) \u2013 Like stdout, but for standard error. stdout_level ( int , default: INFO ) \u2013 stderr_level ( int , default: WARNING ) \u2013 Logging levels for the specific output. prefix ( str , default: '' ) \u2013 A string that is prepended to each line before logging. Returns: the command\u2019s exit code See also aexecute()","title":"execute"},{"location":"api/#logproc.limit_concurrency","text":"Run at most limit of the given awaitables concurrently, yielding completed tasks as they finish.","title":"limit_concurrency"},{"location":"api/#logproc.map_unordered","text":"Executes the given async function func on each item from iterable , yielding results as they complete, while limiting the number of concurrent tasks to limit . This function will not consume more items from iterable than it can start while maintaining the concurrency limit. Parameters: func ( Callable [[ T ], Awaitable [ R ]] ) \u2013 a coroutine function to apply to each item of the given iterable iterable ( Iterable [ T ] | AsyncIterable [ T ] ) \u2013 an iterable or async iterable of items to process limit ( int | None , default: None ) \u2013 Maximum number of concurrent tasks. If None, defaults to the number of CPU cores available to the process. Returns: AsyncGenerator [ R , None] \u2013 The results of the function calls, in the order they complete. See also https://death.andgravity.com/limit-concurrency","title":"map_unordered"},{"location":"api/#logproc.proc_logger","text":"Creates a callback for execute() that logs to a logger. Parameters: prefix ( str , default: '' ) \u2013 String that will be prepended to each line logger ( LoggerSpec , default: None ) \u2013 If given, this is either a logger or the name of a logger. If missing, we log to the root logger. level ( int , default: INFO ) \u2013 The level at which to log the messages.","title":"proc_logger"}]}